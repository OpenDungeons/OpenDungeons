<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AngelScript: asIScriptEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1>asIScriptEngine Class Reference</h1><!-- doxytag: class="asIScriptEngine" -->The engine interface.  

<p>

<p>
<a href="classas_i_script_engine-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory management</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a95a5d9b5d9e7e6a230fedf056eaf8ce">AddRef</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase reference counter.  <a href="#a95a5d9b5d9e7e6a230fedf056eaf8ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ae91a45da75af9234b87e825b5c08b81">Release</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrease reference counter.  <a href="#ae91a45da75af9234b87e825b5c08b81"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Engine properties</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#1bce4e5f573a2ca0ff55163e28f761dd">SetEngineProperty</a> (<a class="el" href="angelscript_8h.html#53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a> property, <a class="el" href="angelscript_8h.html#76fc6994aba7ff6c685a62c273c057e3">asPWORD</a> value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamically change some engine properties.  <a href="#1bce4e5f573a2ca0ff55163e28f761dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="angelscript_8h.html#76fc6994aba7ff6c685a62c273c057e3">asPWORD</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#5531bf5310a0c933aa698725a6828e5f">GetEngineProperty</a> (<a class="el" href="angelscript_8h.html#53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a> property) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve current engine property settings.  <a href="#5531bf5310a0c933aa698725a6828e5f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Compiler messages</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#74192fe950808eb72a64e3e371f0ea02">SetMessageCallback</a> (const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;callback, void *obj, <a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> callConv)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a message callback that will receive compiler messages.  <a href="#74192fe950808eb72a64e3e371f0ea02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#da64567fc9621e5e98160c7f03efa064">ClearMessageCallback</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the registered message callback routine.  <a href="#da64567fc9621e5e98160c7f03efa064"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#936ce6566af958bb75ba1c0945d8b03a">WriteMessage</a> (const char *section, int row, int col, <a class="el" href="angelscript_8h.html#8badcd23652646db5c5c6981dc73d4f5">asEMsgType</a> type, const char *message)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a message to the message callback.  <a href="#936ce6566af958bb75ba1c0945d8b03a"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">JIT compiler</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ee4f910163604203a27db1ffea3b1c9c"></a><!-- doxytag: member="asIScriptEngine::SetJITCompiler" ref="ee4f910163604203a27db1ffea3b1c9c" args="(asIJITCompiler *compiler)=0" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ee4f910163604203a27db1ffea3b1c9c">SetJITCompiler</a> (<a class="el" href="classas_i_j_i_t_compiler.html">asIJITCompiler</a> *compiler)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the JIT compiler. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2fb6db9085df3c7d487c0d58de76bb83"></a><!-- doxytag: member="asIScriptEngine::GetJITCompiler" ref="2fb6db9085df3c7d487c0d58de76bb83" args="() const =0" -->
virtual <a class="el" href="classas_i_j_i_t_compiler.html">asIJITCompiler</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#2fb6db9085df3c7d487c0d58de76bb83">GetJITCompiler</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the JIT compiler. <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Global functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#754fafd069d8e0c19baff2dc222893b0">RegisterGlobalFunction</a> (const char *declaration, const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;funcPointer, <a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> callConv)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a global function.  <a href="#754fafd069d8e0c19baff2dc222893b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#7aa5860f8d35798b712b833b0044b34a">GetGlobalFunctionCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of registered functions.  <a href="#7aa5860f8d35798b712b833b0044b34a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#154f25c36b7d88f73de1b440a169ec08">GetGlobalFunctionIdByIndex</a> (<a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> index) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the function id of the registered function.  <a href="#154f25c36b7d88f73de1b440a169ec08"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Global properties</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#acd32f32b2922b8ffaed204812013169">RegisterGlobalProperty</a> (const char *declaration, void *pointer)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a global property.  <a href="#acd32f32b2922b8ffaed204812013169"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#be467bcfb7cc209ae8bf5dd3dcde05c2">GetGlobalPropertyCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of registered global properties.  <a href="#be467bcfb7cc209ae8bf5dd3dcde05c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#be2bbaac916cc2d70882ed8eb2c44d84">GetGlobalPropertyByIndex</a> (<a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> index, const char **name, int *typeId=0, bool *isConst=0, const char **configGroup=0, void **pointer=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the detail on the registered global property.  <a href="#be2bbaac916cc2d70882ed8eb2c44d84"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Object types</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#29c6c087c8c5b5cdb6271cfd161cc5a6">RegisterObjectType</a> (const char *obj, int byteSize, <a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> flags)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a new object type.  <a href="#29c6c087c8c5b5cdb6271cfd161cc5a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#33f3cd249307f5f11120a395579410f6">RegisterObjectProperty</a> (const char *obj, const char *declaration, int byteOffset)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a property for the object type.  <a href="#33f3cd249307f5f11120a395579410f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#6686c12ef37f4a4b1f9e90997b4756d0">RegisterObjectMethod</a> (const char *obj, const char *declaration, const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;funcPointer, <a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> callConv)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a method for the object type.  <a href="#6686c12ef37f4a4b1f9e90997b4756d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#7ea3c93dea338b0287027de0e4895dcb">RegisterObjectBehaviour</a> (const char *obj, <a class="el" href="angelscript_8h.html#7e38df5b10ec8cbf2a688f1d114097c5">asEBehaviours</a> behaviour, const char *declaration, const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;funcPointer, <a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> callConv)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a behaviour for the object type.  <a href="#7ea3c93dea338b0287027de0e4895dcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#e2d89b82561b7f9843f35693c664589f">RegisterInterface</a> (const char *name)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers an interface.  <a href="#e2d89b82561b7f9843f35693c664589f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#43bd2c12c94a55c22be76d209de93f1a">RegisterInterfaceMethod</a> (const char *intf, const char *declaration)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers an interface method.  <a href="#43bd2c12c94a55c22be76d209de93f1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#8a5335477bb79f4770e59f344a544551">GetObjectTypeCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of registered object types.  <a href="#8a5335477bb79f4770e59f344a544551"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classas_i_object_type.html">asIObjectType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#c0a40a93ca9df41b7e56dd846a98cd92">GetObjectTypeByIndex</a> (<a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> index) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the object type interface by index.  <a href="#c0a40a93ca9df41b7e56dd846a98cd92"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">String factory</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#95ad30812d89dee425240b49675017a4">RegisterStringFactory</a> (const char *datatype, const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;factoryFunc, <a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> callConv)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers the string factory.  <a href="#95ad30812d89dee425240b49675017a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#0bc701479de273e47e6ed6276e8fbb3e">GetStringFactoryReturnTypeId</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the type id of the type that the string factory returns.  <a href="#0bc701479de273e47e6ed6276e8fbb3e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Default array type</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#c9451feece1297eba8d1649036039e82">RegisterDefaultArrayType</a> (const char *type)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers the type that should be used as the default array.  <a href="#c9451feece1297eba8d1649036039e82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#e86e5444979b0abd92777be83c53fc80">GetDefaultArrayTypeId</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the type id of the registered type.  <a href="#e86e5444979b0abd92777be83c53fc80"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Enums</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#bed6e77f2a532c8a4f528650fa137d37">RegisterEnum</a> (const char *type)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers an enum type.  <a href="#bed6e77f2a532c8a4f528650fa137d37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#4d331153596dd39838f3bed2a861af18">RegisterEnumValue</a> (const char *type, const char *name, int value)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers an enum value.  <a href="#4d331153596dd39838f3bed2a861af18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#e043a03b0f016de7c1858147ec7f5338">GetEnumCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of registered enum types.  <a href="#e043a03b0f016de7c1858147ec7f5338"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#e00909c267231faed5d13417239a8b6e">GetEnumByIndex</a> (<a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> index, int *enumTypeId, const char **configGroup=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the registered enum type.  <a href="#e00909c267231faed5d13417239a8b6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#fe82935052b582efbfd536ebda352e98">GetEnumValueCount</a> (int enumTypeId) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of enum values for the enum type.  <a href="#fe82935052b582efbfd536ebda352e98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#cc50d55c389409e3ff699a5e4d6e4ba5">GetEnumValueByIndex</a> (int enumTypeId, <a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> index, int *outValue) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the name and value of the enum value for the enum type.  <a href="#cc50d55c389409e3ff699a5e4d6e4ba5"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Funcdefs</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#03c1a2cc23ae4b742c927f3472a1a4f7">RegisterFuncdef</a> (const char *decl)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a function definition.  <a href="#03c1a2cc23ae4b742c927f3472a1a4f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#c4a370ed3e2a6662b1c196a4da4e5fdb">GetFuncdefCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of registered function definitions.  <a href="#c4a370ed3e2a6662b1c196a4da4e5fdb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#78f526563eb438aaa719dc4510e71fe8">GetFuncdefByIndex</a> (<a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> index, const char **configGroup=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a registered function definition.  <a href="#78f526563eb438aaa719dc4510e71fe8"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ddb24466769dc52be96c7e37d5305245">RegisterTypedef</a> (const char *type, const char *decl)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a typedef.  <a href="#ddb24466769dc52be96c7e37d5305245"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#707f06715308d6629c34cc0fe925b033">GetTypedefCount</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of registered typedefs.  <a href="#707f06715308d6629c34cc0fe925b033"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#4012a89ae60035a41560e61efe498f72">GetTypedefByIndex</a> (<a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> index, int *typeId, const char **configGroup=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a registered typedef.  <a href="#4012a89ae60035a41560e61efe498f72"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Configuration groups</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#c81014e50dd7efc1920adcb3fd2d1e5d">BeginConfigGroup</a> (const char *groupName)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts a new dynamic configuration group.  <a href="#c81014e50dd7efc1920adcb3fd2d1e5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#4cc5ed7ea71811655f7910d298bb5a02">EndConfigGroup</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ends the configuration group.  <a href="#4cc5ed7ea71811655f7910d298bb5a02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#b607be7fe727cdcce502d2beedbf4c0a">RemoveConfigGroup</a> (const char *groupName)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a previously registered configuration group.  <a href="#b607be7fe727cdcce502d2beedbf4c0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#704a7cc1f7455e52a8d2760b110fdb4f">SetConfigGroupModuleAccess</a> (const char *groupName, const char *module, bool hasAccess)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell AngelScript which modules have access to which configuration groups.  <a href="#704a7cc1f7455e52a8d2760b110fdb4f"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Script modules</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classas_i_script_module.html">asIScriptModule</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#9f7cdc52b59034e6e55eb8a56b427aa4">GetModule</a> (const char *module, <a class="el" href="angelscript_8h.html#e4cf50de5273eb8c03c6e91e6e014f0c">asEGMFlags</a> flag=asGM_ONLY_IF_EXISTS)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an interface pointer to the module.  <a href="#9f7cdc52b59034e6e55eb8a56b427aa4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#fb0ce55e5846eb18afdcf906aeb67cf7">DiscardModule</a> (const char *module)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discard a module.  <a href="#fb0ce55e5846eb18afdcf906aeb67cf7"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Script functions</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#b7b9ce9df4fc3e8ffaf1184325b9b01c">GetFunctionDescriptorById</a> (int funcId) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the function descriptor for the script function.  <a href="#b7b9ce9df4fc3e8ffaf1184325b9b01c"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Type identification</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classas_i_object_type.html">asIObjectType</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#52f3e08240c9fc493793036721cbd5ce">GetObjectTypeById</a> (int typeId) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the object type interface for type.  <a href="#52f3e08240c9fc493793036721cbd5ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#d1f6fecb0f53fd7966736b01f65c3dcb">GetTypeIdByDecl</a> (const char *decl) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a type id by declaration.  <a href="#d1f6fecb0f53fd7966736b01f65c3dcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#150137f1732c21291c701f40540b312a">GetTypeDeclaration</a> (int typeId) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a type declaration.  <a href="#150137f1732c21291c701f40540b312a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#39b7207a6c4c55a5cbf10eab2ccfb8e6">GetSizeOfPrimitiveType</a> (int typeId) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of a primitive type.  <a href="#39b7207a6c4c55a5cbf10eab2ccfb8e6"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Script execution</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classas_i_script_context.html">asIScriptContext</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#2630e1cd03ffab0fee9b820bf0afe42a">CreateContext</a> ()=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new script context.  <a href="#2630e1cd03ffab0fee9b820bf0afe42a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#fdc06a65b6df9095835a32fa474c99d3">CreateScriptObject</a> (int typeId)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a script object defined by its type id.  <a href="#fdc06a65b6df9095835a32fa474c99d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#0369a333503be2a232580a85b854779c">CreateScriptObjectCopy</a> (void *obj, int typeId)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of a script object.  <a href="#0369a333503be2a232580a85b854779c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#d299a2adb48c7510e3a167d8cea36789">CopyScriptObject</a> (void *dstObj, void *srcObj, int typeId)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy one script object to another.  <a href="#d299a2adb48c7510e3a167d8cea36789"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#3660c6a075d76df0071b6df35feb227a">ReleaseScriptObject</a> (void *obj, int typeId)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the script object pointer.  <a href="#3660c6a075d76df0071b6df35feb227a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#9b4264280709ed2e97c763a2e0b1f282">AddRefScriptObject</a> (void *obj, int typeId)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increase the reference counter for the script object.  <a href="#9b4264280709ed2e97c763a2e0b1f282"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#282b92f29b371545a6a6f6aa2ccf971e">IsHandleCompatibleWithObject</a> (void *obj, int objTypeId, int handleTypeId) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the object referenced by a handle compatible with the specified type.  <a href="#282b92f29b371545a6a6f6aa2ccf971e"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">String interpretation</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="angelscript_8h.html#012a602727ca3fe1efa27053bc58cbca">asETokenClass</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#db8d7ba77b0b24abea68ba93ac153668">ParseToken</a> (const char *string, size_t stringLength=0, int *tokenLength=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the class and length of the first token in the string.  <a href="#db8d7ba77b0b24abea68ba93ac153668"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Garbage collection</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#4beff0f3d176199019c60d282e87c8d1">GarbageCollect</a> (<a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> flags=asGC_FULL_CYCLE)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform garbage collection.  <a href="#4beff0f3d176199019c60d282e87c8d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#166e6cdd0cb35bcfd942824d8e882783">GetGCStatistics</a> (<a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> *currentSize, <a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> *totalDestroyed=0, <a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> *totalDetected=0, <a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> *newObjects=0, <a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> *totalNewDestroyed=0) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain statistics from the garbage collector.  <a href="#166e6cdd0cb35bcfd942824d8e882783"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#8ea9a6f3ed9f69a5c4e07c87281117c0">NotifyGarbageCollectorOfNewObject</a> (void *obj, int typeId)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify the garbage collector of a new object that needs to be managed.  <a href="#8ea9a6f3ed9f69a5c4e07c87281117c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#58ceeafd780dea3543e0ede4106199fd">GCEnumCallback</a> (void *reference)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by the garbage collector to enumerate all references held by an object.  <a href="#58ceeafd780dea3543e0ede4106199fd"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">User data</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#339b31c7aea69e4132ae7cebc55f3e80">SetUserData</a> (void *data)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register the memory address of some user data.  <a href="#339b31c7aea69e4132ae7cebc55f3e80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#eab55f7073163d10552e02a469b0ef78">GetUserData</a> () const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the address of the previously registered user data.  <a href="#eab55f7073163d10552e02a469b0ef78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#d91d8c1e53489bee1243e351be7e18a9">SetEngineUserDataCleanupCallback</a> (<a class="el" href="angelscript_8h.html#b4583fe7648248c59f525f944cfb9db1">asCLEANENGINEFUNC_t</a> callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the function that should be called when the engine is destroyed.  <a href="#d91d8c1e53489bee1243e351be7e18a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#afa5ed8214fc2029a6b5228e5cf60d6e">SetContextUserDataCleanupCallback</a> (<a class="el" href="angelscript_8h.html#88ecc3288f67d86c6dd9d8d24d9980ca">asCLEANCONTEXTFUNC_t</a> callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the function that should be called when a context is destroyed.  <a href="#afa5ed8214fc2029a6b5228e5cf60d6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#e9585d4e65618b02c6005d3beaca4377">SetFunctionUserDataCleanupCallback</a> (<a class="el" href="angelscript_8h.html#e396d162d9d46c34a7f197ecbc788dfa">asCLEANFUNCTIONFUNC_t</a> callback)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the function that should be called when a function is destroyed.  <a href="#e9585d4e65618b02c6005d3beaca4377"></a><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a95a5d9b5d9e7e6a230fedf056eaf8ce"></a><!-- doxytag: member="asIScriptEngine::AddRef" ref="a95a5d9b5d9e7e6a230fedf056eaf8ce" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::AddRef           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of references to this object.</dd></dl>
Call this method when storing an additional reference to the object. Remember that the first reference that is received from <a class="el" href="angelscript_8h.html#f84c6359750675bf3ceccf373286a533">asCreateScriptEngine</a> is already accounted for. 
</div>
</div><p>
<a class="anchor" name="9b4264280709ed2e97c763a2e0b1f282"></a><!-- doxytag: member="asIScriptEngine::AddRefScriptObject" ref="9b4264280709ed2e97c763a2e0b1f282" args="(void *obj, int typeId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::AddRefScriptObject           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>typeId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj</em>&nbsp;</td><td>A pointer to the object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>typeId</em>&nbsp;</td><td>The type id of the object.</td></tr>
  </table>
</dl>
This calls the add ref method of the object to increase the reference count.<p>
This only works for objects. 
</div>
</div><p>
<a class="anchor" name="c81014e50dd7efc1920adcb3fd2d1e5d"></a><!-- doxytag: member="asIScriptEngine::BeginConfigGroup" ref="c81014e50dd7efc1920adcb3fd2d1e5d" args="(const char *groupName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::BeginConfigGroup           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>groupName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupName</em>&nbsp;</td><td>The name of the configuration group </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asNAME_TAKEN</em>&nbsp;</td><td>Another group with the same name already exists. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNOT_SUPPORTED</em>&nbsp;</td><td>Nesting configuration groups is not supported.</td></tr>
  </table>
</dl>
Starts a new dynamic configuration group. This group can be setup so that it is only visible to specific modules, and it can also be removed when it is no longer used. 
</div>
</div><p>
<a class="anchor" name="da64567fc9621e5e98160c7f03efa064"></a><!-- doxytag: member="asIScriptEngine::ClearMessageCallback" ref="da64567fc9621e5e98160c7f03efa064" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::ClearMessageCallback           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error.</dd></dl>
Call this method to remove the message callback. 
</div>
</div><p>
<a class="anchor" name="d299a2adb48c7510e3a167d8cea36789"></a><!-- doxytag: member="asIScriptEngine::CopyScriptObject" ref="d299a2adb48c7510e3a167d8cea36789" args="(void *dstObj, void *srcObj, int typeId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::CopyScriptObject           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dstObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>srcObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>typeId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dstObj</em>&nbsp;</td><td>A pointer to the destination object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>srcObj</em>&nbsp;</td><td>A pointer to the source object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>typeId</em>&nbsp;</td><td>The type id of the objects.</td></tr>
  </table>
</dl>
This calls the assignment operator to copy the object from one to the other.<p>
This only works for objects. 
</div>
</div><p>
<a class="anchor" name="2630e1cd03ffab0fee9b820bf0afe42a"></a><!-- doxytag: member="asIScriptEngine::CreateContext" ref="2630e1cd03ffab0fee9b820bf0afe42a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_script_context.html">asIScriptContext</a>* asIScriptEngine::CreateContext           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the new script context.</dd></dl>
This method creates a context that will be used to execute the script functions. The context interface created will have its reference counter already increased. 
</div>
</div><p>
<a class="anchor" name="fdc06a65b6df9095835a32fa474c99d3"></a><!-- doxytag: member="asIScriptEngine::CreateScriptObject" ref="fdc06a65b6df9095835a32fa474c99d3" args="(int typeId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* asIScriptEngine::CreateScriptObject           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>typeId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>typeId</em>&nbsp;</td><td>The type id of the object to create. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the new object if successful, or null if not.</dd></dl>
This method is used to create a script object based on it's type id. The method will allocate the memory and call the object's default constructor. Reference counted objects will have their reference counter set to 1 so the application needs to release the pointer when it will no longer use it.<p>
This only works for objects, for primitive types and object handles the method doesn't do anything and returns a null pointer. 
</div>
</div><p>
<a class="anchor" name="0369a333503be2a232580a85b854779c"></a><!-- doxytag: member="asIScriptEngine::CreateScriptObjectCopy" ref="0369a333503be2a232580a85b854779c" args="(void *obj, int typeId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* asIScriptEngine::CreateScriptObjectCopy           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>typeId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj</em>&nbsp;</td><td>A pointer to the source object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>typeId</em>&nbsp;</td><td>The type id of the object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the new object if successful, or null if not.</dd></dl>
This method is used to create a copy of an existing object.<p>
This only works for objects, for primitive types and object handles the method doesn't do anything and returns a null pointer. 
</div>
</div><p>
<a class="anchor" name="fb0ce55e5846eb18afdcf906aeb67cf7"></a><!-- doxytag: member="asIScriptEngine::DiscardModule" ref="fb0ce55e5846eb18afdcf906aeb67cf7" args="(const char *module)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::DiscardModule           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>module</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>module</em>&nbsp;</td><td>The name of the module </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asNO_MODULE</em>&nbsp;</td><td>The module was not found.</td></tr>
  </table>
</dl>
Discards a module and frees its memory. Any pointers that the application holds to this module will be invalid after this call. 
</div>
</div><p>
<a class="anchor" name="4cc5ed7ea71811655f7910d298bb5a02"></a><!-- doxytag: member="asIScriptEngine::EndConfigGroup" ref="4cc5ed7ea71811655f7910d298bb5a02" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::EndConfigGroup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asNOT_SUPPORTED</em>&nbsp;</td><td>Can't end a group that hasn't been begun.</td></tr>
  </table>
</dl>
Ends the current configuration group. Once finished a config group cannot be changed, but it can be removed when it is no longer used. 
</div>
</div><p>
<a class="anchor" name="4beff0f3d176199019c60d282e87c8d1"></a><!-- doxytag: member="asIScriptEngine::GarbageCollect" ref="4beff0f3d176199019c60d282e87c8d1" args="(asDWORD flags=asGC_FULL_CYCLE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GarbageCollect           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>asGC_FULL_CYCLE</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Set to a combination of the <a class="el" href="angelscript_8h.html#c06582350753eb4d89d6ba9442eadf9d">asEGCFlags</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the cycle wasn't completed, 0 if it was.</dd></dl>
This method will free script objects that can no longer be reached. When the engine is released the garbage collector will automatically do a full cycle to release all objects still alive. If the engine is long living it is important to call this method every once in a while to free up memory allocated by the scripts. If a script does a lot of allocations before returning it may be necessary to implement a line callback function that calls the garbage collector during execution of the script.<p>
It is not necessary to do a full cycle with every call. This makes it possible to spread out the garbage collection time over a large period, thus not impacting the responsiveness of the application. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_gc.html">Garbage collection</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="58ceeafd780dea3543e0ede4106199fd"></a><!-- doxytag: member="asIScriptEngine::GCEnumCallback" ref="58ceeafd780dea3543e0ede4106199fd" args="(void *reference)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::GCEnumCallback           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>reference</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reference</em>&nbsp;</td><td>A pointer to the referenced object.</td></tr>
  </table>
</dl>
When processing the EnumReferences call the called object should call GCEnumCallback for each of the references it holds to other objects.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_gc_object.html">Garbage collected objects</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e86e5444979b0abd92777be83c53fc80"></a><!-- doxytag: member="asIScriptEngine::GetDefaultArrayTypeId" ref="e86e5444979b0abd92777be83c53fc80" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetDefaultArrayTypeId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type id, or a negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td>The default array type hasn't been registered. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5531bf5310a0c933aa698725a6828e5f"></a><!-- doxytag: member="asIScriptEngine::GetEngineProperty" ref="5531bf5310a0c933aa698725a6828e5f" args="(asEEngineProp property) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="angelscript_8h.html#76fc6994aba7ff6c685a62c273c057e3">asPWORD</a> asIScriptEngine::GetEngineProperty           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a>&nbsp;</td>
          <td class="paramname"> <em>property</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>property</em>&nbsp;</td><td>One of the <a class="el" href="angelscript_8h.html#53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a> values. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the property, or 0 if it is an invalid property.</dd></dl>
Calling this method lets you determine the current value of the engine properties. 
</div>
</div><p>
<a class="anchor" name="e00909c267231faed5d13417239a8b6e"></a><!-- doxytag: member="asIScriptEngine::GetEnumByIndex" ref="e00909c267231faed5d13417239a8b6e" args="(asUINT index, int *enumTypeId, const char **configGroup=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* asIScriptEngine::GetEnumByIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>enumTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>configGroup</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the enum type. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>enumTypeId</em>&nbsp;</td><td>Receives the type if of the enum type. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>configGroup</em>&nbsp;</td><td>Receives the config group in which the enum was registered. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The name of the registered enum type, or null on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e043a03b0f016de7c1858147ec7f5338"></a><!-- doxytag: member="asIScriptEngine::GetEnumCount" ref="e043a03b0f016de7c1858147ec7f5338" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetEnumCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of registered enum types. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cc50d55c389409e3ff699a5e4d6e4ba5"></a><!-- doxytag: member="asIScriptEngine::GetEnumValueByIndex" ref="cc50d55c389409e3ff699a5e4d6e4ba5" args="(int enumTypeId, asUINT index, int *outValue) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* asIScriptEngine::GetEnumValueByIndex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>enumTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>outValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enumTypeId</em>&nbsp;</td><td>The type id of the enum type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the enum value. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outValue</em>&nbsp;</td><td>Receives the value of the enum value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The name of the enum value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe82935052b582efbfd536ebda352e98"></a><!-- doxytag: member="asIScriptEngine::GetEnumValueCount" ref="fe82935052b582efbfd536ebda352e98" args="(int enumTypeId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetEnumValueCount           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>enumTypeId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enumTypeId</em>&nbsp;</td><td>The type id of the enum type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of enum values for the enum type. </dd></dl>

</div>
</div><p>
<a class="anchor" name="78f526563eb438aaa719dc4510e71fe8"></a><!-- doxytag: member="asIScriptEngine::GetFuncdefByIndex" ref="78f526563eb438aaa719dc4510e71fe8" args="(asUINT index, const char **configGroup=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a>* asIScriptEngine::GetFuncdefByIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>configGroup</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the funcdef. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>configGroup</em>&nbsp;</td><td>The config group in which the funcdef was registered. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The funcdef.</dd></dl>
This function does not increase the reference count of the return function definition. 
</div>
</div><p>
<a class="anchor" name="c4a370ed3e2a6662b1c196a4da4e5fdb"></a><!-- doxytag: member="asIScriptEngine::GetFuncdefCount" ref="c4a370ed3e2a6662b1c196a4da4e5fdb" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetFuncdefCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of registered funcdefs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b7b9ce9df4fc3e8ffaf1184325b9b01c"></a><!-- doxytag: member="asIScriptEngine::GetFunctionDescriptorById" ref="b7b9ce9df4fc3e8ffaf1184325b9b01c" args="(int funcId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a>* asIScriptEngine::GetFunctionDescriptorById           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>funcId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>funcId</em>&nbsp;</td><td>The id of the function or method. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the function description interface, or null if not found.</dd></dl>
This does not increment the reference count of the returned function descriptor. 
</div>
</div><p>
<a class="anchor" name="166e6cdd0cb35bcfd942824d8e882783"></a><!-- doxytag: member="asIScriptEngine::GetGCStatistics" ref="166e6cdd0cb35bcfd942824d8e882783" args="(asUINT *currentSize, asUINT *totalDestroyed=0, asUINT *totalDetected=0, asUINT *newObjects=0, asUINT *totalNewDestroyed=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::GetGCStatistics           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> *&nbsp;</td>
          <td class="paramname"> <em>currentSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> *&nbsp;</td>
          <td class="paramname"> <em>totalDestroyed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> *&nbsp;</td>
          <td class="paramname"> <em>totalDetected</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> *&nbsp;</td>
          <td class="paramname"> <em>newObjects</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a> *&nbsp;</td>
          <td class="paramname"> <em>totalNewDestroyed</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>currentSize</em>&nbsp;</td><td>The current number of objects known to the garbage collector. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>totalDestroyed</em>&nbsp;</td><td>The total number of objects destroyed by the garbage collector. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>totalDetected</em>&nbsp;</td><td>The total number of objects detected as garbage with circular references. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>newObjects</em>&nbsp;</td><td>The current number of objects in the new generation. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>totalNewDestroyed</em>&nbsp;</td><td>The total number of objects destroyed while still in the new generation.</td></tr>
  </table>
</dl>
This method can be used to query the number of objects that the garbage collector is keeping track of. If the number is very large then it is probably time to call the <a class="el" href="classas_i_script_engine.html#4beff0f3d176199019c60d282e87c8d1">GarbageCollect</a> method so that some of the objects ca be freed.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_gc.html">Garbage collection</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7aa5860f8d35798b712b833b0044b34a"></a><!-- doxytag: member="asIScriptEngine::GetGlobalFunctionCount" ref="7aa5860f8d35798b712b833b0044b34a" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetGlobalFunctionCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of registered functions. </dd></dl>

</div>
</div><p>
<a class="anchor" name="154f25c36b7d88f73de1b440a169ec08"></a><!-- doxytag: member="asIScriptEngine::GetGlobalFunctionIdByIndex" ref="154f25c36b7d88f73de1b440a169ec08" args="(asUINT index) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetGlobalFunctionIdByIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the registered global function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The id of the function, or a negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_ARG</em>&nbsp;</td><td><em>index</em> is too large. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="be2bbaac916cc2d70882ed8eb2c44d84"></a><!-- doxytag: member="asIScriptEngine::GetGlobalPropertyByIndex" ref="be2bbaac916cc2d70882ed8eb2c44d84" args="(asUINT index, const char **name, int *typeId=0, bool *isConst=0, const char **configGroup=0, void **pointer=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetGlobalPropertyByIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>typeId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>isConst</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>configGroup</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>pointer</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the global variable. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>Receives the name of the property. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>typeId</em>&nbsp;</td><td>Receives the typeId of the property. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>isConst</em>&nbsp;</td><td>Receives the constness indicator of the property. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>configGroup</em>&nbsp;</td><td>Receives the config group in which the property was registered. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pointer</em>&nbsp;</td><td>Receives the pointer of the property. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_ARG</em>&nbsp;</td><td><em>index</em> is too large. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="be467bcfb7cc209ae8bf5dd3dcde05c2"></a><!-- doxytag: member="asIScriptEngine::GetGlobalPropertyCount" ref="be467bcfb7cc209ae8bf5dd3dcde05c2" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetGlobalPropertyCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of registered global properties. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f7cdc52b59034e6e55eb8a56b427aa4"></a><!-- doxytag: member="asIScriptEngine::GetModule" ref="9f7cdc52b59034e6e55eb8a56b427aa4" args="(const char *module, asEGMFlags flag=asGM_ONLY_IF_EXISTS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_script_module.html">asIScriptModule</a>* asIScriptEngine::GetModule           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#e4cf50de5273eb8c03c6e91e6e014f0c">asEGMFlags</a>&nbsp;</td>
          <td class="paramname"> <em>flag</em> = <code>asGM_ONLY_IF_EXISTS</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>module</em>&nbsp;</td><td>The name of the module </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flag</em>&nbsp;</td><td>One of the <a class="el" href="angelscript_8h.html#e4cf50de5273eb8c03c6e91e6e014f0c">asEGMFlags</a> flags </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the module interface</dd></dl>
Use this method to get access to the module interface, which will let you build new scripts, and enumerate functions and types in existing modules.<p>
If <a class="el" href="angelscript_8h.html#e4cf50de5273eb8c03c6e91e6e014f0c0843ab784ed9a9ea6cb47d915825186f">asGM_ALWAYS_CREATE</a> is informed as the flag the previous module with the same name will be discarded, thus any pointers that the engine holds to it will be invalid after the call. 
</div>
</div><p>
<a class="anchor" name="52f3e08240c9fc493793036721cbd5ce"></a><!-- doxytag: member="asIScriptEngine::GetObjectTypeById" ref="52f3e08240c9fc493793036721cbd5ce" args="(int typeId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_object_type.html">asIObjectType</a>* asIScriptEngine::GetObjectTypeById           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>typeId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>typeId</em>&nbsp;</td><td>The type id of the type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The object type interface for the type, or null if not found.</dd></dl>
This does not increment the reference count of the returned object type. 
</div>
</div><p>
<a class="anchor" name="c0a40a93ca9df41b7e56dd846a98cd92"></a><!-- doxytag: member="asIScriptEngine::GetObjectTypeByIndex" ref="c0a40a93ca9df41b7e56dd846a98cd92" args="(asUINT index) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_object_type.html">asIObjectType</a>* asIScriptEngine::GetObjectTypeByIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The registered object type interface for the type, or null if not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a5335477bb79f4770e59f344a544551"></a><!-- doxytag: member="asIScriptEngine::GetObjectTypeCount" ref="8a5335477bb79f4770e59f344a544551" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetObjectTypeCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of object types registered by the application. </dd></dl>

</div>
</div><p>
<a class="anchor" name="39b7207a6c4c55a5cbf10eab2ccfb8e6"></a><!-- doxytag: member="asIScriptEngine::GetSizeOfPrimitiveType" ref="39b7207a6c4c55a5cbf10eab2ccfb8e6" args="(int typeId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetSizeOfPrimitiveType           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>typeId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>typeId</em>&nbsp;</td><td>The type id of the type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The size of the type in bytes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0bc701479de273e47e6ed6276e8fbb3e"></a><!-- doxytag: member="asIScriptEngine::GetStringFactoryReturnTypeId" ref="0bc701479de273e47e6ed6276e8fbb3e" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetStringFactoryReturnTypeId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type id of the type that the string type returns, or a negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asNO_FUNCTION</em>&nbsp;</td><td>The string factory has not been registered. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="150137f1732c21291c701f40540b312a"></a><!-- doxytag: member="asIScriptEngine::GetTypeDeclaration" ref="150137f1732c21291c701f40540b312a" args="(int typeId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* asIScriptEngine::GetTypeDeclaration           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>typeId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>typeId</em>&nbsp;</td><td>The type id of the type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A null terminated string with the type declaration, or null if not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4012a89ae60035a41560e61efe498f72"></a><!-- doxytag: member="asIScriptEngine::GetTypedefByIndex" ref="4012a89ae60035a41560e61efe498f72" args="(asUINT index, int *typeId, const char **configGroup=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* asIScriptEngine::GetTypedefByIndex           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#c8186f029686800b7ce36bde4a55c815">asUINT</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>configGroup</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the typedef. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>typeId</em>&nbsp;</td><td>The type that the typedef aliases. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>configGroup</em>&nbsp;</td><td>Receives the config group in which the type def was registered. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The name of the typedef. </dd></dl>

</div>
</div><p>
<a class="anchor" name="707f06715308d6629c34cc0fe925b033"></a><!-- doxytag: member="asIScriptEngine::GetTypedefCount" ref="707f06715308d6629c34cc0fe925b033" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetTypedefCount           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of registered typedefs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d1f6fecb0f53fd7966736b01f65c3dcb"></a><!-- doxytag: member="asIScriptEngine::GetTypeIdByDecl" ref="d1f6fecb0f53fd7966736b01f65c3dcb" args="(const char *decl) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetTypeIdByDecl           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>decl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>decl</em>&nbsp;</td><td>The declaration of the type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error, or the type id of the type. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td><em>decl</em> is not a valid type.</td></tr>
  </table>
</dl>
Translates a type declaration into a type id. The returned type id is valid for as long as the type is valid, so you can safely store it for later use to avoid potential overhead by calling this function each time. Just remember to update the type id, any time the type is changed within the engine, e.g. when recompiling script declared classes, or changing the engine configuration.<p>
The type id is based on a sequence number and depends on the order in which the type ids are queried, thus is not guaranteed to always be the same for each execution of the application. The <a class="el" href="angelscript_8h.html#e8c3a67a97321be53181e9ed396ad83a">asETypeIdFlags</a> can be used to obtain some information about the type directly from the id.<p>
A base type yields the same type id whether the declaration is const or not, however if the const is for the subtype then the type id is different, e.g. string@ isn't the same as const string@ but string is the same as const string.<p>
This method is only able to return the type id that are not specific for a script module, i.e. built-in types and application registered types. Type ids for script declared types should be obtained through the script module's <a class="el" href="classas_i_script_module.html#7fbc2bd888b248d2c2ee2d953b49eefc">GetTypeIdByDecl</a>. 
</div>
</div><p>
<a class="anchor" name="eab55f7073163d10552e02a469b0ef78"></a><!-- doxytag: member="asIScriptEngine::GetUserData" ref="eab55f7073163d10552e02a469b0ef78" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* asIScriptEngine::GetUserData           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pointer to the user data. </dd></dl>

</div>
</div><p>
<a class="anchor" name="282b92f29b371545a6a6f6aa2ccf971e"></a><!-- doxytag: member="asIScriptEngine::IsHandleCompatibleWithObject" ref="282b92f29b371545a6a6f6aa2ccf971e" args="(void *obj, int objTypeId, int handleTypeId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool asIScriptEngine::IsHandleCompatibleWithObject           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>objTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>handleTypeId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj</em>&nbsp;</td><td>A pointer to the object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>objTypeId</em>&nbsp;</td><td>The type id of the object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>handleTypeId</em>&nbsp;</td><td>The type id of the handle. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns true if the handle type is compatible with the object type.</dd></dl>
This method can be used to determine if a handle of a certain type is compatible with an object of another type. This is useful if you have a pointer to a object, but only knows that it implements a certain interface and now you want to determine if it implements another interface. 
</div>
</div><p>
<a class="anchor" name="8ea9a6f3ed9f69a5c4e07c87281117c0"></a><!-- doxytag: member="asIScriptEngine::NotifyGarbageCollectorOfNewObject" ref="8ea9a6f3ed9f69a5c4e07c87281117c0" args="(void *obj, int typeId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::NotifyGarbageCollectorOfNewObject           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>typeId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj</em>&nbsp;</td><td>A pointer to the newly created object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>typeId</em>&nbsp;</td><td>The type id of the object.</td></tr>
  </table>
</dl>
This method should be called when a new garbage collected object is created. The GC will then store a reference to the object so that it can automatically detect whether the object is involved in any circular references that should be released.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_gc_object.html">Garbage collected objects</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="db8d7ba77b0b24abea68ba93ac153668"></a><!-- doxytag: member="asIScriptEngine::ParseToken" ref="db8d7ba77b0b24abea68ba93ac153668" args="(const char *string, size_t stringLength=0, int *tokenLength=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="angelscript_8h.html#012a602727ca3fe1efa27053bc58cbca">asETokenClass</a> asIScriptEngine::ParseToken           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>stringLength</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>tokenLength</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>string</em>&nbsp;</td><td>The string to parse. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stringLength</em>&nbsp;</td><td>The length of the string. Can be 0 if the string is null terminated. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tokenLength</em>&nbsp;</td><td>Gives the length of the identified token. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="angelscript_8h.html#012a602727ca3fe1efa27053bc58cbca">asETokenClass</a> values.</dd></dl>
This function is useful for those applications that want to tokenize strings into tokens that the script language uses, e.g. IDEs providing syntax highlighting, or intellisense. It can also be used to parse the meta data strings that may be declared for script entities. 
</div>
</div><p>
<a class="anchor" name="c9451feece1297eba8d1649036039e82"></a><!-- doxytag: member="asIScriptEngine::RegisterDefaultArrayType" ref="c9451feece1297eba8d1649036039e82" args="(const char *type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterDefaultArrayType           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The name of the template type, e.g. array&lt;T&gt; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td>The type is not a template type </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bed6e77f2a532c8a4f528650fa137d37"></a><!-- doxytag: member="asIScriptEngine::RegisterEnum" ref="bed6e77f2a532c8a4f528650fa137d37" args="(const char *type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterEnum           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The name of the enum type. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_NAME</em>&nbsp;</td><td><em>type</em> is null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asALREADY_REGISTERED</em>&nbsp;</td><td>Another type with this name already exists. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asERROR</em>&nbsp;</td><td>The <em>type</em> couldn't be parsed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_NAME</em>&nbsp;</td><td>The <em>type</em> is not an identifier, or it is a reserved keyword. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNAME_TAKEN</em>&nbsp;</td><td>The type name is already taken.</td></tr>
  </table>
</dl>
This method registers an enum type in the engine. The enum values should then be registered with <a class="el" href="classas_i_script_engine.html#4d331153596dd39838f3bed2a861af18">RegisterEnumValue</a>. 
</div>
</div><p>
<a class="anchor" name="4d331153596dd39838f3bed2a861af18"></a><!-- doxytag: member="asIScriptEngine::RegisterEnumValue" ref="4d331153596dd39838f3bed2a861af18" args="(const char *type, const char *name, int value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterEnumValue           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The name of the enum type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the enum value. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The integer value of the enum value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asWRONG_CONFIG_GROUP</em>&nbsp;</td><td>The enum <em>type</em> was registered in a different configuration group. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td>The <em>type</em> is invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asALREADY_REGISTERED</em>&nbsp;</td><td>The <em>name</em> is already registered for this enum.</td></tr>
  </table>
</dl>
This method registers an enum value for a previously registered enum type. 
</div>
</div><p>
<a class="anchor" name="03c1a2cc23ae4b742c927f3472a1a4f7"></a><!-- doxytag: member="asIScriptEngine::RegisterFuncdef" ref="03c1a2cc23ae4b742c927f3472a1a4f7" args="(const char *decl)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterFuncdef           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>decl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>decl</em>&nbsp;</td><td>The declaration of the function definition. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_ARG</em>&nbsp;</td><td>The <em>decl</em> parameter is not given. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_DECLARATION</em>&nbsp;</td><td><em>decl</em> is not a valid function definition. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNAME_TAKEN</em>&nbsp;</td><td>The name of the funcdef conflicts with another name.</td></tr>
  </table>
</dl>
<a class="el" href="doc_datatypes_funcptr.html">Funcdefs</a> are used to define the signature of function pointers. If the application is going to receive function pointers from scripts, it is necessary to first register the funcdef before registering the function or property that will be used to receive it. 
</div>
</div><p>
<a class="anchor" name="754fafd069d8e0c19baff2dc222893b0"></a><!-- doxytag: member="asIScriptEngine::RegisterGlobalFunction" ref="754fafd069d8e0c19baff2dc222893b0" args="(const char *declaration, const asSFuncPtr &amp;funcPointer, asDWORD callConv)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterGlobalFunction           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>declaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>funcPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&nbsp;</td>
          <td class="paramname"> <em>callConv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>declaration</em>&nbsp;</td><td>The declaration of the global function in script syntax. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>funcPointer</em>&nbsp;</td><td>The function pointer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callConv</em>&nbsp;</td><td>The calling convention for the function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error, or the function id if successful. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asNOT_SUPPORTED</em>&nbsp;</td><td>The calling convention is not supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asWRONG_CALLING_CONV</em>&nbsp;</td><td>The function's calling convention doesn't match <em>callConv</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_DECLARATION</em>&nbsp;</td><td>The function declaration is invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNAME_TAKEN</em>&nbsp;</td><td>The function name is already used elsewhere.</td></tr>
  </table>
</dl>
This method registers system functions that the scripts may use to communicate with the host application.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_register_func.html">Registering a function</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="acd32f32b2922b8ffaed204812013169"></a><!-- doxytag: member="asIScriptEngine::RegisterGlobalProperty" ref="acd32f32b2922b8ffaed204812013169" args="(const char *declaration, void *pointer)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterGlobalProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>declaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pointer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>declaration</em>&nbsp;</td><td>The declaration of the global property in script syntax. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pointer</em>&nbsp;</td><td>The address of the property that will be used to access the property value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_DECLARATION</em>&nbsp;</td><td>The declaration has invalid syntax. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td>The declaration is a reference. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNAME_TAKEN</em>&nbsp;</td><td>The name is already taken.</td></tr>
  </table>
</dl>
Use this method to register a global property that the scripts will be able to access as global variables. The property may optionally be registered as const, if the scripts shouldn't be allowed to modify it.<p>
When registering the property, the application must pass the address to the actual value. The application must also make sure that this address remains valid throughout the life time of this registration, i.e. until the engine is released or the dynamic configuration group is removed. 
</div>
</div><p>
<a class="anchor" name="e2d89b82561b7f9843f35693c664589f"></a><!-- doxytag: member="asIScriptEngine::RegisterInterface" ref="e2d89b82561b7f9843f35693c664589f" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterInterface           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the interface. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_NAME</em>&nbsp;</td><td>The <em>name</em> is null, or a reserved keyword. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asALREADY_REGISTERED</em>&nbsp;</td><td>An object type with this name already exists. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asERROR</em>&nbsp;</td><td>The <em>name</em> is not a proper identifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNAME_TAKEN</em>&nbsp;</td><td>The <em>name</em> is already used elsewhere.</td></tr>
  </table>
</dl>
This registers an interface that script classes can implement. By doing this the application can register functions and methods that receives an <a class="el" href="classas_i_script_object.html">asIScriptObject</a> and still be sure that the class implements certain methods needed by the application. 
</div>
</div><p>
<a class="anchor" name="43bd2c12c94a55c22be76d209de93f1a"></a><!-- doxytag: member="asIScriptEngine::RegisterInterfaceMethod" ref="43bd2c12c94a55c22be76d209de93f1a" args="(const char *intf, const char *declaration)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterInterfaceMethod           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>intf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>declaration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>intf</em>&nbsp;</td><td>The name of the interface. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>declaration</em>&nbsp;</td><td>The method declaration. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asWRONG_CONFIG_GROUP</em>&nbsp;</td><td>The interface was registered in another configuration group. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td><em>intf</em> is not an interface type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_DECLARATION</em>&nbsp;</td><td>The <em>declaration</em> is invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNAME_TAKEN</em>&nbsp;</td><td>The method name is already taken.</td></tr>
  </table>
</dl>
This registers a method that the class that implements the interface must have. 
</div>
</div><p>
<a class="anchor" name="7ea3c93dea338b0287027de0e4895dcb"></a><!-- doxytag: member="asIScriptEngine::RegisterObjectBehaviour" ref="7ea3c93dea338b0287027de0e4895dcb" args="(const char *obj, asEBehaviours behaviour, const char *declaration, const asSFuncPtr &amp;funcPointer, asDWORD callConv)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterObjectBehaviour           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#7e38df5b10ec8cbf2a688f1d114097c5">asEBehaviours</a>&nbsp;</td>
          <td class="paramname"> <em>behaviour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>declaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>funcPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&nbsp;</td>
          <td class="paramname"> <em>callConv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj</em>&nbsp;</td><td>The name of the type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>behaviour</em>&nbsp;</td><td>One of the object behaviours from <a class="el" href="angelscript_8h.html#7e38df5b10ec8cbf2a688f1d114097c5">asEBehaviours</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>declaration</em>&nbsp;</td><td>The declaration of the method in script syntax. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>funcPointer</em>&nbsp;</td><td>The method or function pointer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callConv</em>&nbsp;</td><td>The calling convention for the method or function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error, or the function id is successful. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asWRONG_CONFIG_GROUP</em>&nbsp;</td><td>The object type was registered in a different configuration group. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_ARG</em>&nbsp;</td><td><em>obj</em> is not set, or a global behaviour is given in <em>behaviour</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asWRONG_CALLING_CONV</em>&nbsp;</td><td>The function's calling convention isn't compatible with <em>callConv</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNOT_SUPPORTED</em>&nbsp;</td><td>The calling convention or the behaviour signature is not supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td>The <em>obj</em> parameter is not a valid object name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_DECLARATION</em>&nbsp;</td><td>The <em>declaration</em> is invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asILLEGAL_BEHAVIOUR_FOR_TYPE</em>&nbsp;</td><td>The <em>behaviour</em> is not allowed for this type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asALREADY_REGISTERED</em>&nbsp;</td><td>The behaviour is already registered with the same signature.</td></tr>
  </table>
</dl>
Use this method to register behaviour functions that will be called by the virtual machine to perform certain operations, such as memory management, math operations, comparisons, etc.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_register_func.html">Registering a function</a>, <a class="el" href="doc_reg_opbeh.html">Registering operator behaviours</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6686c12ef37f4a4b1f9e90997b4756d0"></a><!-- doxytag: member="asIScriptEngine::RegisterObjectMethod" ref="6686c12ef37f4a4b1f9e90997b4756d0" args="(const char *obj, const char *declaration, const asSFuncPtr &amp;funcPointer, asDWORD callConv)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterObjectMethod           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>declaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>funcPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&nbsp;</td>
          <td class="paramname"> <em>callConv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj</em>&nbsp;</td><td>The name of the type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>declaration</em>&nbsp;</td><td>The declaration of the method in script syntax. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>funcPointer</em>&nbsp;</td><td>The method or function pointer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callConv</em>&nbsp;</td><td>The calling convention for the method or function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error, or the function id if successful. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asWRONG_CONFIG_GROUP</em>&nbsp;</td><td>The object type was registered in a different configuration group. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNOT_SUPPORTED</em>&nbsp;</td><td>The calling convention is not supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td>The <em>obj</em> parameter is not a valid object name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_DECLARATION</em>&nbsp;</td><td>The <em>declaration</em> is invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNAME_TAKEN</em>&nbsp;</td><td>The name conflicts with other members. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asWRONG_CALLING_CONV</em>&nbsp;</td><td>The function's calling convention isn't compatible with <em>callConv</em>.</td></tr>
  </table>
</dl>
Use this method to register a member method for the type. The method that is registered may be an actual class method, or a global function that takes the object pointer as either the first or last parameter. Or it may be a global function implemented with the generic calling convention.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_register_func.html">Registering a function</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="33f3cd249307f5f11120a395579410f6"></a><!-- doxytag: member="asIScriptEngine::RegisterObjectProperty" ref="33f3cd249307f5f11120a395579410f6" args="(const char *obj, const char *declaration, int byteOffset)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterObjectProperty           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>declaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byteOffset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj</em>&nbsp;</td><td>The name of the type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>declaration</em>&nbsp;</td><td>The property declaration in script syntax. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byteOffset</em>&nbsp;</td><td>The offset into the memory block where this property is found. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asWRONG_CONFIG_GROUP</em>&nbsp;</td><td>The object type was registered in a different configuration group. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_OBJECT</em>&nbsp;</td><td>The <em>obj</em> does not specify an object type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td>The <em>obj</em> parameter has invalid syntax. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_DECLARATION</em>&nbsp;</td><td>The <em>declaration</em> is invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNAME_TAKEN</em>&nbsp;</td><td>The name conflicts with other members.</td></tr>
  </table>
</dl>
Use this method to register a member property of a class. The property must be local to the object, i.e. not a global variable or a static member. The easiest way to get the offset of the property is to use the offsetof macro from stddef.h.<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>MyType {<span class="keywordtype">float</span> prop;};
 r = engine-&gt;<a class="code" href="classas_i_script_engine.html#33f3cd249307f5f11120a395579410f6" title="Registers a property for the object type.">RegisterObjectProperty</a>(<span class="stringliteral">"MyType"</span>, <span class="stringliteral">"float prop"</span>, offsetof(MyType, prop)));
</pre></div> 
</div>
</div><p>
<a class="anchor" name="29c6c087c8c5b5cdb6271cfd161cc5a6"></a><!-- doxytag: member="asIScriptEngine::RegisterObjectType" ref="29c6c087c8c5b5cdb6271cfd161cc5a6" args="(const char *obj, int byteSize, asDWORD flags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterObjectType           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byteSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj</em>&nbsp;</td><td>The name of the type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byteSize</em>&nbsp;</td><td>The size of the type in bytes. Only necessary for value types. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>One or more of the asEObjTypeFlags. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The type id on success or a negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_ARG</em>&nbsp;</td><td>The flags are invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_NAME</em>&nbsp;</td><td>The name is invalid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asALREADY_REGISTERED</em>&nbsp;</td><td>Another type of the same name already exists. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNAME_TAKEN</em>&nbsp;</td><td>The name conflicts with other symbol names. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asLOWER_ARRAY_DIMENSION_NOT_REGISTERED</em>&nbsp;</td><td>When registering an array type the array element must be a primitive or a registered type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td>The array type was not properly formed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNOT_SUPPORTED</em>&nbsp;</td><td>The array type is not supported, or already in use preventing it from being overloaded.</td></tr>
  </table>
</dl>
Use this method to register new types that should be available to the scripts. Reference types, which have their memory managed by the application, should be registered with <a class="el" href="angelscript_8h.html#855d86fa9ee15b9f75e553ee376b5c7a9450e038342b36c745858d2e5ae4b861">asOBJ_REF</a>. Value types, which have their memory managed by the engine, should be registered with <a class="el" href="angelscript_8h.html#855d86fa9ee15b9f75e553ee376b5c7a9fc16a8ac0f30f9ff9c6568e0b7be91d">asOBJ_VALUE</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_register_type.html">Registering an object type</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="95ad30812d89dee425240b49675017a4"></a><!-- doxytag: member="asIScriptEngine::RegisterStringFactory" ref="95ad30812d89dee425240b49675017a4" args="(const char *datatype, const asSFuncPtr &amp;factoryFunc, asDWORD callConv)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterStringFactory           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>factoryFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&nbsp;</td>
          <td class="paramname"> <em>callConv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>datatype</em>&nbsp;</td><td>The datatype that the string factory returns </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>factoryFunc</em>&nbsp;</td><td>The pointer to the factory function </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callConv</em>&nbsp;</td><td>The calling convention of the factory function </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error, or the function id if successful. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asNOT_SUPPORTED</em>&nbsp;</td><td>The calling convention is not supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asWRONG_CALLING_CONV</em>&nbsp;</td><td>The function's calling convention doesn't match <em>callConv</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td>The <em>datatype</em> is not a valid type.</td></tr>
  </table>
</dl>
Use this function to register a string factory that will be called when the virtual machine finds a string constant in an expression. The string factory function will receive two parameters, the length of the string constant in bytes and a pointer to the character data. The factory should return a value to a previously registered type that will represent the string. Example:<p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Our string factory implementation</span>
 std::string StringFactory(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> byteLength, <span class="keyword">const</span> <span class="keywordtype">char</span> *s)
 {
     <span class="keywordflow">return</span> std::string(s, byteLength);
 }

 <span class="comment">// Registering the string factory</span>
 <span class="keywordtype">int</span> r = engine-&gt;<a class="code" href="classas_i_script_engine.html#95ad30812d89dee425240b49675017a4" title="Registers the string factory.">RegisterStringFactory</a>(<span class="stringliteral">"string"</span>, <a class="code" href="angelscript_8h.html#78f8f2c7f1c88b12e74a5ac47b4184ae" title="Returns an asSFuncPtr representing the function specified by the name.">asFUNCTION</a>(StringFactory), <a class="code" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e468ae43cc91cdfc3fa4590c9e6164e4f4" title="A cdecl function.">asCALL_CDECL</a>); assert( r &gt;= 0 );
</pre></div><p>
The example assumes that the std::string type has been registered as the string type, with <a class="el" href="classas_i_script_engine.html#29c6c087c8c5b5cdb6271cfd161cc5a6">RegisterObjectType</a>. 
</div>
</div><p>
<a class="anchor" name="ddb24466769dc52be96c7e37d5305245"></a><!-- doxytag: member="asIScriptEngine::RegisterTypedef" ref="ddb24466769dc52be96c7e37d5305245" args="(const char *type, const char *decl)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterTypedef           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>decl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The name of the new typedef </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>decl</em>&nbsp;</td><td>The datatype that the typedef represents </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_NAME</em>&nbsp;</td><td>The <em>type</em> is null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asALREADY_REGISTERED</em>&nbsp;</td><td>A type with the same name already exists. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_TYPE</em>&nbsp;</td><td>The <em>decl</em> is not a primitive type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_NAME</em>&nbsp;</td><td>The <em>type</em> is not an identifier, or it is a reserved keyword. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNAME_TAKEN</em>&nbsp;</td><td>The name is already used elsewhere.</td></tr>
  </table>
</dl>
This method registers an alias for a data type.<p>
Currently typedefs can only be registered for built-in primitive types. 
</div>
</div><p>
<a class="anchor" name="ae91a45da75af9234b87e825b5c08b81"></a><!-- doxytag: member="asIScriptEngine::Release" ref="ae91a45da75af9234b87e825b5c08b81" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::Release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of references to this object.</dd></dl>
Call this method when you will no longer use the references that you own. 
</div>
</div><p>
<a class="anchor" name="3660c6a075d76df0071b6df35feb227a"></a><!-- doxytag: member="asIScriptEngine::ReleaseScriptObject" ref="3660c6a075d76df0071b6df35feb227a" args="(void *obj, int typeId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::ReleaseScriptObject           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>typeId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj</em>&nbsp;</td><td>A pointer to the object. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>typeId</em>&nbsp;</td><td>The type id of the object.</td></tr>
  </table>
</dl>
This calls the release method of the object to release the reference.<p>
This only works for objects. 
</div>
</div><p>
<a class="anchor" name="b607be7fe727cdcce502d2beedbf4c0a"></a><!-- doxytag: member="asIScriptEngine::RemoveConfigGroup" ref="b607be7fe727cdcce502d2beedbf4c0a" args="(const char *groupName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RemoveConfigGroup           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>groupName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupName</em>&nbsp;</td><td>The name of the configuration group </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asCONFIG_GROUP_IS_IN_USE</em>&nbsp;</td><td>The group is in use and cannot be removed.</td></tr>
  </table>
</dl>
Remove the configuration group. If something in the configuration group is currently in use, the function will return with an error code. Examples of uses are compiled modules that have function calls to functions in the group and global variables of types registered in the group. 
</div>
</div><p>
<a class="anchor" name="704a7cc1f7455e52a8d2760b110fdb4f"></a><!-- doxytag: member="asIScriptEngine::SetConfigGroupModuleAccess" ref="704a7cc1f7455e52a8d2760b110fdb4f" args="(const char *groupName, const char *module, bool hasAccess)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::SetConfigGroupModuleAccess           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>groupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>hasAccess</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupName</em>&nbsp;</td><td>The name of the configuration group </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>module</em>&nbsp;</td><td>The module name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hasAccess</em>&nbsp;</td><td>Whether the module has access or not to the group members </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asWRONG_CONFIG_GROUP</em>&nbsp;</td><td>No group with the <em>groupName</em> was found.</td></tr>
  </table>
</dl>
With this method the application can give modules access to individual configuration groups. This is useful when exposing more than one script interface for various parts of the application, e.g. one interface for GUI handling, another for in-game events, etc.<p>
The default module access is granted. The default for a group can be changed by specifying the modulename asALL_MODULES. 
</div>
</div><p>
<a class="anchor" name="afa5ed8214fc2029a6b5228e5cf60d6e"></a><!-- doxytag: member="asIScriptEngine::SetContextUserDataCleanupCallback" ref="afa5ed8214fc2029a6b5228e5cf60d6e" args="(asCLEANCONTEXTFUNC_t callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::SetContextUserDataCleanupCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#88ecc3288f67d86c6dd9d8d24d9980ca">asCLEANCONTEXTFUNC_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>A pointer to the function</td></tr>
  </table>
</dl>
The function given with this call will be invoked when a context is destroyed if any <a class="el" href="classas_i_script_context.html#78e92b53c248534cd278a1498b88680d">user data</a> has been registered with the context.<p>
The function is called from within the context destructor, so the callback should not be used for anything but cleaning up the user data itself. 
</div>
</div><p>
<a class="anchor" name="1bce4e5f573a2ca0ff55163e28f761dd"></a><!-- doxytag: member="asIScriptEngine::SetEngineProperty" ref="1bce4e5f573a2ca0ff55163e28f761dd" args="(asEEngineProp property, asPWORD value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::SetEngineProperty           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a>&nbsp;</td>
          <td class="paramname"> <em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#76fc6994aba7ff6c685a62c273c057e3">asPWORD</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>property</em>&nbsp;</td><td>One of the <a class="el" href="angelscript_8h.html#53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a> values. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The new value of the property. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_ARG</em>&nbsp;</td><td>Invalid property.</td></tr>
  </table>
</dl>
With this method you can change the way the script engine works in some regards. 
</div>
</div><p>
<a class="anchor" name="d91d8c1e53489bee1243e351be7e18a9"></a><!-- doxytag: member="asIScriptEngine::SetEngineUserDataCleanupCallback" ref="d91d8c1e53489bee1243e351be7e18a9" args="(asCLEANENGINEFUNC_t callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::SetEngineUserDataCleanupCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#b4583fe7648248c59f525f944cfb9db1">asCLEANENGINEFUNC_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>A pointer to the function</td></tr>
  </table>
</dl>
The function given with this call will be invoked when the engine is destroyed if any <a class="el" href="classas_i_script_engine.html#339b31c7aea69e4132ae7cebc55f3e80">user data</a> has been registered with the engine.<p>
The function is called from within the engine destructor, so the callback should not be used for anything but cleaning up the user data itself. 
</div>
</div><p>
<a class="anchor" name="e9585d4e65618b02c6005d3beaca4377"></a><!-- doxytag: member="asIScriptEngine::SetFunctionUserDataCleanupCallback" ref="e9585d4e65618b02c6005d3beaca4377" args="(asCLEANFUNCTIONFUNC_t callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::SetFunctionUserDataCleanupCallback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#e396d162d9d46c34a7f197ecbc788dfa">asCLEANFUNCTIONFUNC_t</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>A pointer to the function</td></tr>
  </table>
</dl>
The function given with this call will be invoked when a function is destroyed if any <a class="el" href="classas_i_script_function.html#2d01c604a619cbb9a4356a05d041e252">user data</a> has been registered with the function.<p>
The function is called from within the function destructor, so the callback should not be used for anything but cleaning up the user data itself. 
</div>
</div><p>
<a class="anchor" name="74192fe950808eb72a64e3e371f0ea02"></a><!-- doxytag: member="asIScriptEngine::SetMessageCallback" ref="74192fe950808eb72a64e3e371f0ea02" args="(const asSFuncPtr &amp;callback, void *obj, asDWORD callConv)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::SetMessageCallback           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&nbsp;</td>
          <td class="paramname"> <em>callConv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>A function or class method pointer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>obj</em>&nbsp;</td><td>The object for methods, or an optional parameter for functions. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callConv</em>&nbsp;</td><td>The calling convention. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value for an error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_ARG</em>&nbsp;</td><td>One of the arguments is incorrect, e.g. obj is null for a class method. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asNOT_SUPPORTED</em>&nbsp;</td><td>The arguments are not supported, e.g. asCALL_GENERIC.</td></tr>
  </table>
</dl>
This method sets the callback routine that will receive compiler messages. The callback routine can be either a class method, e.g: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> MyClass::MessageCallback(<span class="keyword">const</span> <a class="code" href="structas_s_message_info.html" title="Represents a compiler message.">asSMessageInfo</a> *msg);
 r = engine-&gt;<a class="code" href="classas_i_script_engine.html#74192fe950808eb72a64e3e371f0ea02" title="Sets a message callback that will receive compiler messages.">SetMessageCallback</a>(<a class="code" href="angelscript_8h.html#7345e6b3afabec24efd0ff77886d49a6" title="Returns an asSFuncPtr representing the class method specified by class and method...">asMETHOD</a>(MyClass,MessageCallback), &amp;obj, <a class="code" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e4ea516c8742acc1edff6a43dc1bb09e96" title="A thiscall class method.">asCALL_THISCALL</a>);
</pre></div> or a global function, e.g: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> MessageCallback(<span class="keyword">const</span> <a class="code" href="structas_s_message_info.html" title="Represents a compiler message.">asSMessageInfo</a> *msg, <span class="keywordtype">void</span> *param);
 r = engine-&gt;<a class="code" href="classas_i_script_engine.html#74192fe950808eb72a64e3e371f0ea02" title="Sets a message callback that will receive compiler messages.">SetMessageCallback</a>(<a class="code" href="angelscript_8h.html#78f8f2c7f1c88b12e74a5ac47b4184ae" title="Returns an asSFuncPtr representing the function specified by the name.">asFUNCTION</a>(MessageCallback), param, <a class="code" href="angelscript_8h.html#3ec92ea3c4762e44c2df788ceccdd1e468ae43cc91cdfc3fa4590c9e6164e4f4" title="A cdecl function.">asCALL_CDECL</a>);
</pre></div> It is recommended to register the message callback routine right after creating the engine, as some of the registration functions can provide useful information to better explain errors. 
</div>
</div><p>
<a class="anchor" name="339b31c7aea69e4132ae7cebc55f3e80"></a><!-- doxytag: member="asIScriptEngine::SetUserData" ref="339b31c7aea69e4132ae7cebc55f3e80" args="(void *data)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* asIScriptEngine::SetUserData           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to the user data. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The previous pointer stored in the engine.</dd></dl>
This method allows the application to associate a value, e.g. a pointer, with the engine instance.<p>
Optionally, a callback function can be <a class="el" href="classas_i_script_engine.html#d91d8c1e53489bee1243e351be7e18a9">registered</a> to clean up the user data when the engine is destroyed. 
</div>
</div><p>
<a class="anchor" name="936ce6566af958bb75ba1c0945d8b03a"></a><!-- doxytag: member="asIScriptEngine::WriteMessage" ref="936ce6566af958bb75ba1c0945d8b03a" args="(const char *section, int row, int col, asEMsgType type, const char *message)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::WriteMessage           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#8badcd23652646db5c5c6981dc73d4f5">asEMsgType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>section</em>&nbsp;</td><td>The name of the script section. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>row</em>&nbsp;</td><td>The row number. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>col</em>&nbsp;</td><td>The column number. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>The message type. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>The message text. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>asINVALID_ARG</em>&nbsp;</td><td>The section or message is null.</td></tr>
  </table>
</dl>
This method can be used by the application to write messages to the same message callback that the script compiler uses. This is useful for example if a preprocessor is used. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="angelscript_8h.html">angelscript.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Jul 3 18:09:37 2011 for AngelScript by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
