<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AngelScript: Co-routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="doc_adv_coroutine">Co-routines </a></h1>Co-routines is a way to allow multiple execution paths in parallel, but without the hazards of pre-emptive scheduling in <a class="el" href="doc_adv_concurrent.html">multithreading</a> where one thread can be suspended at any moment so another can resume. Because co-routines always voluntarily suspend themselves in favor of the next co-routine, there is no need to worry about atomic instructions and critical sections.<p>
Co-routines are not natively built-into the AngelScript library, but it can easily be implemented from the application side. In fact, the <a class="el" href="doc_addon_ctxmgr.html">Context manager</a> add-on already provides a default implementation for this.<p>
To implement your own version of co-routines you will need a couple of pieces:<p>
<ul>
<li>The co-routine itself, which is just an instance of the <a class="el" href="classas_i_script_context.html">asIScriptContext</a> object. Each co-routine will have its own context object that holds the callstack of the co-routine.</li><li>A function that will permit the script to create, or spawn, new co-routines. This function will need to be able to refer to starting function of the new co-routine. This reference can be done by name, or perhaps more elegantly with a <a class="el" href="doc_datatypes_funcptr.html">function pointer</a>. Once invoked this function will instanciate the new context, and prepare it with the starting function.</li><li>A function that will permit a co-routine to yield control to the next co-routine. This function will simply suspend the current context so the next co-routine can be resumed.</li><li>A simple control algorithm for the co-routines. This can just be a loop that will iterate over an array of co-routines, i.e. contexts, until all of them have finished executing. When a new co-routine is created it is simply appended to the array to be picked up when the current co-routine yields the control.</li></ul>
<p>
A simple implementation of the function that spawns a new co-routine may look like this:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> CreateCoRoutine(<span class="keywordtype">string</span> &amp;func)
{
  <a class="code" href="classas_i_script_context.html" title="The interface to the virtual machine.">asIScriptContext</a> *ctx = <a class="code" href="angelscript_8h.html#d3a20dc58093b92a5a44c7b6ada34a10" title="Returns the currently active context.">asGetActiveContext</a>();
  <span class="keywordflow">if</span>( ctx )
  {
    <a class="code" href="classas_i_script_engine.html" title="The engine interface.">asIScriptEngine</a> *engine = ctx-&gt;<a class="code" href="classas_i_script_context.html#07f12016c5435aec5b63449abb6e4d8d" title="Returns a pointer to the engine.">GetEngine</a>();
    <span class="keywordtype">string</span> mod = ctx-&gt;<a class="code" href="classas_i_script_context.html#1c101300447f2909e5d188409a7180f6" title="Returns the function at the specified callstack level.">GetFunction</a>()-&gt;<a class="code" href="classas_i_script_function.html#f03c30e4764f81c01400d7f77a8d0832" title="Returns the name of the module where the function was implemented.">GetModuleName</a>();

    <span class="comment">// We need to find the function that will be created as the co-routine</span>
    <span class="keywordtype">string</span> decl = <span class="stringliteral">"void "</span> + func + <span class="stringliteral">"()"</span>; 
    <span class="keywordtype">int</span> funcId = engine-&gt;<a class="code" href="classas_i_script_engine.html#9f7cdc52b59034e6e55eb8a56b427aa4" title="Return an interface pointer to the module.">GetModule</a>(mod.c_str())-&gt;GetFunctionIdByDecl(decl.c_str());
    <span class="keywordflow">if</span>( funcId &lt; 0 )
    {
      <span class="comment">// No function could be found, raise an exception</span>
      ctx-&gt;<a class="code" href="classas_i_script_context.html#4ed608208cafdebe5676df079e27d392" title="Sets an exception, which aborts the execution.">SetException</a>((<span class="stringliteral">"Function '"</span> + decl + <span class="stringliteral">"' doesn't exist"</span>).c_str());
      <span class="keywordflow">return</span>;
    }

    <span class="comment">// Create a new context for the co-routine</span>
    <a class="code" href="classas_i_script_context.html" title="The interface to the virtual machine.">asIScriptContext</a> *coctx = engine-&gt;<a class="code" href="classas_i_script_engine.html#2630e1cd03ffab0fee9b820bf0afe42a" title="Creates a new script context.">CreateContext</a>();
    coctx-&gt;<a class="code" href="classas_i_script_context.html#d048f847854cc8b95fde0380a8b39d7e" title="Prepares the context for execution of the function identified by funcId.">Prepare</a>(funcId);

    <span class="comment">// Add the new co-routine context to the array of co-routines</span>
    coroutines.push_back(coctx);
  }
}
</pre></div><p>
The yield function is even simpler:<p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> Yield()
{
  <a class="code" href="classas_i_script_context.html" title="The interface to the virtual machine.">asIScriptContext</a> *ctx = <a class="code" href="angelscript_8h.html#d3a20dc58093b92a5a44c7b6ada34a10" title="Returns the currently active context.">asGetActiveContext</a>();
  <span class="keywordflow">if</span>( ctx )
  { 
    <span class="comment">// Suspend the context so the next co-routine can be resumed</span>
    ctx-&gt;<a class="code" href="classas_i_script_context.html#d4ac8be3586c46069b5870e40c86544a" title="Suspends the execution, which can then be resumed by calling Execute again.">Suspend</a>();
  }
}
</pre></div><p>
A basic control algorithm might look like this:<p>
<div class="fragment"><pre class="fragment">std::vector&lt;asIScriptContext *&gt; coroutines;
<span class="keywordtype">void</span> Execute()
{
  <span class="keywordtype">int</span> n = 0;
  <span class="keywordflow">while</span>( coroutines.size() &gt; 0 )
  {
    <span class="comment">// Resume the co-routine</span>
    <span class="keywordtype">int</span> r = coroutines[n]-&gt;Execute();
    <span class="keywordflow">if</span>( r == <a class="code" href="angelscript_8h.html#867f14b4137dd4602fda1e616b217a697b5644be315c46f2fa44f032731242c7" title="The execution is suspended and can be resumed.">asEXECUTION_SUSPENDED</a> )
    {
      <span class="comment">// Resume the next co-routine</span>
      <span class="keywordflow">if</span>( ++n == coroutines.size() )
        n = 0;
    }
    <span class="keywordflow">else</span>
    {
      <span class="comment">// The co-routine finished so let's remove it</span>
      coroutines[n]-&gt;Release();
      coroutines.erase(n);
    }
  }
}
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_addon_ctxmgr.html">Context manager</a>, <a class="el" href="doc_samples_corout.html">Co-routines</a>, <a class="el" href="doc_adv_concurrent.html">Concurrent scripts</a> </dd></dl>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Jul 3 18:09:37 2011 for AngelScript by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
