<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AngelScript: Globals</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="doc_global">Globals </a></h1>All global declarations share the same namespace so their names may not conflict. This includes extended data types and built-in functions registered by the host application. Also, all declarations are visible to all, e.g. a function to be called does not have to be declared above the function that calls it.<p>
<ul>
<li>
<a class="el" href="doc_global.html#doc_global_function">Functions</a> </li>
<li>
<a class="el" href="doc_global.html#doc_global_variable">Variables</a> </li>
<li>
<a class="el" href="doc_global.html#doc_global_class">Classes</a> </li>
<li>
<a class="el" href="doc_global.html#doc_global_interface">Interfaces</a> </li>
<li>
<a class="el" href="doc_global.html#doc_global_import">Imports</a> </li>
<li>
<a class="el" href="doc_global.html#doc_global_enums">Enums</a> </li>
<li>
<a class="el" href="doc_global.html#doc_global_typedef">Typedefs</a> </li>
<li>
<a class="el" href="doc_global.html#doc_global_funcdef">Funcdefs</a> </li>
</ul>
<h2><a class="anchor" name="doc_global_function">
Functions</a></h2>
Global functions are declared normally, just as in C/C++. The function body must be defined, i.e. it is not possible to declare prototypes, nor is it necessary as the compiler can resolve the function names anyway.<p>
For parameters sent by reference, i.e. with the <code>&amp;</code> modifier it is necessary to specify in which direction the value is passed, <code>in</code>, <code>out</code>, or <code>inout</code>, e.g. <code>&amp;out</code>. If no keyword is used, the compiler assumes the <code>inout</code> modifier. For parameters marked with <code>in</code>, the value is passed in to the function, and for parameters marked with <code>out</code> the value is returned from the function.<p>
Parameters can also be declared as <code>const</code> which prohibits the alteration of their value. It is good practice to declare variables that will not be changed as <code>const</code>, because it makes for more readable code and the compiler is also able to take advantage of it some times. Especially for <code>const &amp;in</code> the compiler is many times able to avoid a copy of the value.<p>
Parameters can have default arguments. When a function with default arguments is called, it is not necessary to explicitly inform the value of the arguments, as the compiler can automatically use the default arg. This is especially useful when functions have some arguments that rarely change.<p>
<pre>
  // Declaration of a normal function
  int MyFunction(int a, int b)
  {
    return a + b;
  }</pre><p>
<pre>  // Declaration of a function with default argument
  int MyFuncWithDefArg(int a, int b = 0)
  {
    return a + b;
  }
</pre><h2><a class="anchor" name="doc_global_variable">
Variables</a></h2>
Global variables may be declared in the scripts, which will then be shared between all contexts accessing the script module.<p>
Variables declared globally like this are accessible from all functions. The value of the variables are initialized at compile time and any changes are maintained between calls. If a global variable holds a memory resource, e.g. a string, its memory is released when the module is discarded or the script engine is reset.<p>
<pre>
  int MyValue = 0;
  const uint Flag1 = 0x01;
</pre><p>
Variables of primitive types are initialized before variables of non-primitive types. This allows class constructors to access other global variables already with their correct initial value. The exception is if the other global variable also is of a non-primitive type, in which case there is no guarantee which variable is initialized first, which may lead to null-pointer exceptions being thrown during initialization.<p>
Be careful with calling functions that may access global variables from within the initialization expression of global variables. While the compiler tries to initialize the global variables in the order they are needed, there is no guarantee that it will always succeed. Should a function access a global variable that has not yet been initialized you will get unpredictable behaviour or a null-pointer exception.<h2><a class="anchor" name="doc_global_class">
Classes</a></h2>
In AngelScript the script writer may declare script classes. The syntax is similar to that of C++ or Java.<p>
With classes the script writer can declare new data types that hold groups of variables and methods to manipulate them. The classes also supports inheritance and polymorphism through <a class="el" href="doc_global.html#doc_global_interface">interfaces</a>.<p>
<pre>
  // The class declaration
  class MyClass
  {
    // The default constructor
    MyClass()
    {
      a = 0;
    }</pre><p>
<pre>    // A class method
    void DoSomething()
    {
      a *= 2;
    }</pre><p>
<pre>    // A class property
    int a;
  }
</pre><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_script_class.html">Script classes</a></dd></dl>
<h2><a class="anchor" name="doc_global_interface">
Interfaces</a></h2>
An interface works like a contract, the classes that implements an interface are guaranteed to implement the methods declared in the interface. This allows for the use of polymorphism in that a function can specify that it wants an object handle to an object that implements a certain interface. The function can then call the methods on this interface without having to know the exact type of the object that it is working with.<p>
<pre>
  // The interface declaration
  interface MyInterface
  {
    void DoSomething();
  }</pre><p>
<pre>  // A class that implements the interface MyInterface
  class MyClass : MyInterface
  {
    void DoSomething()
    {
      // Do something
    }
  }
</pre><p>
A class can implement multiple interfaces; Simply list all the interfaces separated by a comma.<h2><a class="anchor" name="doc_global_import">
Imports</a></h2>
Sometimes it may be useful to load script modules dynamically without having to recompile the main script, but still let the modules interact with each other. In that case the script may import functions from another module. This declaration is written using the import keyword, followed by the function signature, and then specifying which module to import from.<p>
This allows the script to be compiled using these imported functions, without them actually being available at compile time. The application can then bind the functions at a later time, and even unbind them again.<p>
If a script is calling an imported function that has not yet been bound the script will be aborted with a script exception.<p>
<pre>
  import void MyFunction(int a, int b) from "Another module";
</pre><h2><a class="anchor" name="doc_global_enums">
Enums</a></h2>
Enums are a convenient way of registering a family of integer constants that may be used throughout the script as named literals instead of numeric constants. Using enums often help improve the readability of the code, as the named literal normally explains what the intention is without the reader having to look up what a numeric value means in the manual.<p>
Even though enums list the valid values, you cannot rely on a variable of the enum type to only contain values from the declared list. Always have a default action in case the variable holds an unexpected value.<p>
The enum values are declared by listing them in an enum statement. Unless a specific value is given for an enum constant it will take the value of the previous constant + 1. The first constant will receive the value 0, unless otherwise specified.<p>
<pre>
  enum MyEnum
  {
    eValue0,
    eValue2 = 2,
    eValue3,
    eValue200 = eValue2 * 100
  }
</pre><h2><a class="anchor" name="doc_global_typedef">
Typedefs</a></h2>
Typedefs are used to define aliases for other types.<p>
Currently a typedef can only be used to define an alias for primitive types, but a future version will have more complete support for all kinds of types.<p>
<pre>
  typedef float  real32;
  typedef double real64;
</pre><h2><a class="anchor" name="doc_global_funcdef">
Funcdefs</a></h2>
Funcdefs are used to define a function signature that will be used to store pointers to functions with matching signatures. With this a function pointer can be created, which is able to store dynamic pointers that can be invoked at a later time as a normal function call.<p>
<pre>
  // Define a function signature for the function pointer
  funcdef bool CALLBACK(int, int);
</pre><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="doc_datatypes_funcptr.html">Function pointers</a> for more information on how to use this </dd></dl>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Jul 3 18:09:37 2011 for AngelScript by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
